==============================
GRAMATYKA
==============================

-- Typy
TypeName -> Type | ArrayType | TupleType
TypeModifier -> "readonly" | <epsilon>
TypeDef -> TypeModifier TypeName
====

Type -> "bool" | "int" | "string"
ArrayType -> Type "[]"
TupleType -> "(" TypeList ")"
TypeList -> TypeList "," TypeName | TypeName
====

-- tworzenie tablicy z n elementami i wypełnienie domyślnymi wartościami
ArrayInit -> "new" Type "[" NumObj "]"
====

AnyObj -> VarName | IntLiteral | Arithmetic | StringLiteral | BoolLiteral | Comparison | AnyObjArray | AnyObjTuple | ArrayInit | FunCall
NumObj -> VarName | IntLiteral | Arithmetic
BoolObj -> VarName | BoolLiteral | Comparison

-- definiowanie zawartości listy np. "[1, 2, 3, 10]" albo krotki (konstrukcja krotki) np. "(1, true, "aaa", 5, someVar)"
AnyObjList -> AnyObjList "," AnyObj | AnyObj
AnyObjArray -> "[" AnyObjList "]"
AnyObjTuple -> "(" AnyObjList ")"
===

-- dostęp do n-tego elementu zdeklarowanej listy (indeksowanie od 0)
ArrayAccess -> VarName "[" NumObj "]"
===

-- Arytmetyka, porównanie
Arithmetic -> ArithmeticBody | "(" ArithmeticBody ")"
ArithmeticBody -> NumObj ArOp NumObj
Comparison -> ComparisonBody | "(" ComparisonBody ")"
ComparisonBody -> AnyObj CompOp AnyObj

-- Deklaracja zmiennej np. "int a"
VarDecl -> TypeDef VarName
-- Przypisanie zmiennej np. "a = 10"
VarAssign -> VarName Assign
Assign -> "=" AnyObj
-- Deklaracja i przypisanie zmiennej np. "int a = 10"
VarDeclAssign -> VarDecl Assign
-- Deklaracja i przypisanie z krotki (dekonstrukcja) np. "(readonly int a, string b, bool c) = (1, "aa", true)"
TupleDeconstr -> "(" VarDeclList ")" Assign
VarDeclList -> VarDeclList "," VarDecl | VarDecl
===

-- Instrukcja return
Return -> "return" AnyObj | "return"
-- Sterowanie pętlą
Break -> "break"
Continue -> "continue"
===

-- Ciało funkcji/pętli/itd.
StmtBlock -> "{" StmtList "}"
StmtList = StmtList Stmt | Stmt
Stmt -> VarDecl ";"
    | VarAssign ";"
    | VarDeclAssign ";"
    | TupleDeconstr ";"
    | WhileLoop
    | IfBranch
    | IfElseBranch
    | FunCall ";"
    | FunDef
    | Return ";"
    | Break ";"
    | Continue ";"
    | SubBodyBlock
    | ";"

-- Wołanie funkcji np. "print("aaaaaaa")"
FunCall -> FunName "(" ArgList ")"
ArgList -> ArgList "," AnyObj | AnyObj
===

-- Definiowanie funkcji
FunDef -> FunRetType FunName "(" ParamList ")" StmtBlock
FunRetType -> "void" | TypeName
ParamList -> ParamList "," VarDecl | VarDecl
===

-- if/if else
IfBranch -> "if" "(" BoolObj ")" Stmt
IfElseBranch -> "if" "(" BoolObj ")" StmtBlock "else" Stmt
-- Pętle
WhileLoop -> "while" "(" BoolObj ")" Stmt
ForLoop -> "for" "(" VarAssign "to" NumObj ")" Stmt
===

Program -> FunList
FunList -> FunList FunDef | FunDef
===


==============================
Przykładowe programy
==============================

Program 1:

int main()
{
    printStr("hello world!")!
    return 0;
}


Program 2:

void useTuple((string, int, bool) t)
{
    (readonly string a, readonly int b, readonly bool c) = t;
    printStr(a);
    printInt(b);
    printBool(c);
}

int main()
{
    useTuple(("aaaaa", 10, true));
    return 0;
}


Program 3:

int[] generateArray(int c)
{
    int[] arr = new int[c];
    for (i = 1 to c)
        arr[i - 1] = i;
    return arr;
}

int main()
{
    readonly int[] arr = generateArray(10);
    for (i = 1 to 10)
        printInt(arr[i - 1]);
    return 0;
}


Program 4:

int main()
{
    int increment(int n)
    {
        return n + 1;
    }

    readonly int n = increment(1);
    printInt(n);
    return 0;
}


==============================
Opis języka
==============================

Prosty język proceduralny, w większości podobny do Javy:
- Deklaracja i przypisywanie zmiennych
- Zmienne read-only (przez dodanie "readonly" przed nazwą typu w deklaracji)
- Pętla while
- Procedury i funkcje zwracające wartość
- Tablice (przez dodanie "[]" po nazwie typu w deklaracji, stworzenie nowej tablicy przez "new <type>[<count>])
- Wypisywanie przez 3 predefiniowane funkcje "printStr", "printInt", "printBool"
- Statyczne typowanie

Elementy nie-Javowe:
- Pętla for jak w Pascalu
- Zagnieżdżanie funkcji/procedur
- Konstrukcja/dekonstrukcja krotek podobna jak w C#

If-else z wymaganym blokiem po if, tzn. "if (...) { ... } else <blok lub instrukcja>" żeby uniknąć niejednoznaczności.


==============================
Tabelka
==============================

  Na 15 punktów
  01 (trzy typy) (+)
  02 (literały, arytmetyka, porównania) (+)
  03 (zmienne, przypisanie) (+)
  04 (print) (+)
  05 (while, if) (+)
  06 (funkcje lub procedury, rekurencja) (+)
  07 (przez zmienną / przez wartość / in/out)
  08 (zmienne read-only i pętla for) (+)
  Na 20 punktów
  09 (przesłanianie i statyczne wiązanie) (+)
  10 (obsługa błędów wykonania) (+)
  11 (funkcje zwracające wartość) (+)
  Na 30 punktów
  12 (4) (statyczne typowanie) (+)
  13 (2) (funkcje zagnieżdżone ze statycznym wiązaniem) (+)
  14 (1/2) (rekordy/listy/tablice/tablice wielowymiarowe) (+ indeksowane tablice)
  15 (2) (krotki z przypisaniem) (+)
  16 (1) (break, continue) (+)
  17 (4) (funkcje wyższego rzędu, anonimowe, domknięcia)
  18 (3) (generatory)

Razem: 30