-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language gram.

module Gram.Abs where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

type PrimType = PrimType' BNFC'Position
data PrimType' a = PTBool a | PTString a | PTInt a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type BoolLit = BoolLit' BNFC'Position
data BoolLit' a = BTrue a | BFalse a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TypeMod = TypeMod' BNFC'Position
data TypeMod' a = TMNone a | TMReadonly a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TypeName = TypeName' BNFC'Position
data TypeName' a
    = TNPrim a (PrimType' a)
    | TNArr a (ArrayType' a)
    | TNTuple a (TupleType' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TypeDef = TypeDef' BNFC'Position
data TypeDef' a = TypeDefin a (TypeName' a) (TypeMod' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ArrayType = ArrayType' BNFC'Position
data ArrayType' a = TArrayType a (TypeName' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TupleType = TupleType' BNFC'Position
data TupleType' a = TTupleType a [TupleSubType' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TupleSubType = TupleSubType' BNFC'Position
data TupleSubType' a = TupleSType a (TypeName' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Prog = Prog' BNFC'Position
data Prog' a = Program a [FunDef' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FunDef = FunDef' BNFC'Position
data FunDef' a
    = FunDefin a (FunRet' a) Ident [FunParam' a] (StmtBlock' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FunRet = FunRet' BNFC'Position
data FunRet' a = FRType a (TypeName' a) | FRVoid a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FunParam = FunParam' BNFC'Position
data FunParam' a = FunPar a (TypeDef' a) Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type StmtBlock = StmtBlock' BNFC'Position
data StmtBlock' a = StmtBlck a [BlockStmt' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type BlockStmt = BlockStmt' BNFC'Position
data BlockStmt' a = BSStmt a (Stmt' a) | BSFunDef a (FunDef' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ArrayInit = ArrayInit' BNFC'Position
data ArrayInit' a = ArrInit a (TypeName' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ArrayConstruction = ArrayConstruction' BNFC'Position
data ArrayConstruction' a = ArrConstr a [ConstrEl' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TupleConstruction = TupleConstruction' BNFC'Position
data TupleConstruction' a = TupleConstr a [ConstrEl' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ConstrEl = ConstrEl' BNFC'Position
data ConstrEl' a = ConstrElem a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ArrayAccess = ArrayAccess' BNFC'Position
data ArrayAccess' a = ArrAcc a Ident (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type CompOp = CompOp' BNFC'Position
data CompOp' a
    = COEq a | CONeq a | COGt a | COLt a | COGe a | COLe a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type AddOp = AddOp' BNFC'Position
data AddOp' a = AOPlus a | AOMinus a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type MulOp = MulOp' BNFC'Position
data MulOp' a = MOMul a | MODiv a | MOMod a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type IntLiteral = IntLiteral' BNFC'Position
data IntLiteral' a = LInt a Integer | LNInt a Integer
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Exp = Exp' BNFC'Position
data Exp' a
    = EInt a (IntLiteral' a)
    | EString a String
    | EBool a (BoolLit' a)
    | EVarRef a Ident
    | EArrInit a (ArrayInit' a)
    | EArrConstr a (ArrayConstruction' a)
    | ETupleConstr a (TupleConstruction' a)
    | EArrAcc a (ArrayAccess' a)
    | EFunCall a (FunCall' a)
    | EMul a (Exp' a) (MulOp' a) (Exp' a)
    | EAdd a (Exp' a) (AddOp' a) (Exp' a)
    | EComp a (Exp' a) (CompOp' a) (Exp' a)
    | EAnd a (Exp' a) (Exp' a)
    | EOr a (Exp' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type VarAssign = VarAssign' BNFC'Position
data VarAssign' a = AVar a Ident (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ArrAccAssign = ArrAccAssign' BNFC'Position
data ArrAccAssign' a = AArrAcc a (ArrayAccess' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type DeclA = DeclA' BNFC'Position
data DeclA' a
    = DeclASingl a (TypeDef' a) Ident | DeclATuple a [DeclA' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FunCall = FunCall' BNFC'Position
data FunCall' a = FuncCall a Ident [FunArg' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type FunArg = FunArg' BNFC'Position
data FunArg' a = FuncArg a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type IfBranch = IfBranch' BNFC'Position
data IfBranch' a = IfBr a (Exp' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type IfElseBranch = IfElseBranch' BNFC'Position
data IfElseBranch' a = IfElBr a (Exp' a) (StmtBlock' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type LoopWhile = LoopWhile' BNFC'Position
data LoopWhile' a = LWhile a (Exp' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type LoopFor = LoopFor' BNFC'Position
data LoopFor' a = LFor a (VarAssign' a) (Exp' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Stmt = Stmt' BNFC'Position
data Stmt' a
    = SEmpty a
    | SDecl a (TypeDef' a) Ident
    | SAssign a (VarAssign' a)
    | SArrAssign a (ArrAccAssign' a)
    | SDeclAssign a (DeclA' a) (Exp' a)
    | SFunCall a (FunCall' a)
    | SIf a (IfBranch' a)
    | SIfEl a (IfElseBranch' a)
    | SLoopWhile a (LoopWhile' a)
    | SLoopFor a (LoopFor' a)
    | SReturn a
    | SReturnVal a (Exp' a)
    | SContinue a
    | SBreak a
    | SSubBlock a (StmtBlock' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition PrimType where
  hasPosition = \case
    PTBool p -> p
    PTString p -> p
    PTInt p -> p

instance HasPosition BoolLit where
  hasPosition = \case
    BTrue p -> p
    BFalse p -> p

instance HasPosition TypeMod where
  hasPosition = \case
    TMNone p -> p
    TMReadonly p -> p

instance HasPosition TypeName where
  hasPosition = \case
    TNPrim p _ -> p
    TNArr p _ -> p
    TNTuple p _ -> p

instance HasPosition TypeDef where
  hasPosition = \case
    TypeDefin p _ _ -> p

instance HasPosition ArrayType where
  hasPosition = \case
    TArrayType p _ -> p

instance HasPosition TupleType where
  hasPosition = \case
    TTupleType p _ -> p

instance HasPosition TupleSubType where
  hasPosition = \case
    TupleSType p _ -> p

instance HasPosition Prog where
  hasPosition = \case
    Program p _ -> p

instance HasPosition FunDef where
  hasPosition = \case
    FunDefin p _ _ _ _ -> p

instance HasPosition FunRet where
  hasPosition = \case
    FRType p _ -> p
    FRVoid p -> p

instance HasPosition FunParam where
  hasPosition = \case
    FunPar p _ _ -> p

instance HasPosition StmtBlock where
  hasPosition = \case
    StmtBlck p _ -> p

instance HasPosition BlockStmt where
  hasPosition = \case
    BSStmt p _ -> p
    BSFunDef p _ -> p

instance HasPosition ArrayInit where
  hasPosition = \case
    ArrInit p _ _ -> p

instance HasPosition ArrayConstruction where
  hasPosition = \case
    ArrConstr p _ -> p

instance HasPosition TupleConstruction where
  hasPosition = \case
    TupleConstr p _ -> p

instance HasPosition ConstrEl where
  hasPosition = \case
    ConstrElem p _ -> p

instance HasPosition ArrayAccess where
  hasPosition = \case
    ArrAcc p _ _ -> p

instance HasPosition CompOp where
  hasPosition = \case
    COEq p -> p
    CONeq p -> p
    COGt p -> p
    COLt p -> p
    COGe p -> p
    COLe p -> p

instance HasPosition AddOp where
  hasPosition = \case
    AOPlus p -> p
    AOMinus p -> p

instance HasPosition MulOp where
  hasPosition = \case
    MOMul p -> p
    MODiv p -> p
    MOMod p -> p

instance HasPosition IntLiteral where
  hasPosition = \case
    LInt p _ -> p
    LNInt p _ -> p

instance HasPosition Exp where
  hasPosition = \case
    EInt p _ -> p
    EString p _ -> p
    EBool p _ -> p
    EVarRef p _ -> p
    EArrInit p _ -> p
    EArrConstr p _ -> p
    ETupleConstr p _ -> p
    EArrAcc p _ -> p
    EFunCall p _ -> p
    EMul p _ _ _ -> p
    EAdd p _ _ _ -> p
    EComp p _ _ _ -> p
    EAnd p _ _ -> p
    EOr p _ _ -> p

instance HasPosition VarAssign where
  hasPosition = \case
    AVar p _ _ -> p

instance HasPosition ArrAccAssign where
  hasPosition = \case
    AArrAcc p _ _ -> p

instance HasPosition DeclA where
  hasPosition = \case
    DeclASingl p _ _ -> p
    DeclATuple p _ -> p

instance HasPosition FunCall where
  hasPosition = \case
    FuncCall p _ _ -> p

instance HasPosition FunArg where
  hasPosition = \case
    FuncArg p _ -> p

instance HasPosition IfBranch where
  hasPosition = \case
    IfBr p _ _ -> p

instance HasPosition IfElseBranch where
  hasPosition = \case
    IfElBr p _ _ _ -> p

instance HasPosition LoopWhile where
  hasPosition = \case
    LWhile p _ _ -> p

instance HasPosition LoopFor where
  hasPosition = \case
    LFor p _ _ _ -> p

instance HasPosition Stmt where
  hasPosition = \case
    SEmpty p -> p
    SDecl p _ _ -> p
    SAssign p _ -> p
    SArrAssign p _ -> p
    SDeclAssign p _ _ -> p
    SFunCall p _ -> p
    SIf p _ -> p
    SIfEl p _ -> p
    SLoopWhile p _ -> p
    SLoopFor p _ -> p
    SReturn p -> p
    SReturnVal p _ -> p
    SContinue p -> p
    SBreak p -> p
    SSubBlock p _ -> p

