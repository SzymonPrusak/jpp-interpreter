-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Gram.Par
  ( happyError
  , myLexer
  , pProg
  ) where

import Prelude

import qualified Gram.Abs
import Gram.Lex

}

%name pProg_internal Prog
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)  }
  '%'        { PT _ (TS _ 2)  }
  '&&'       { PT _ (TS _ 3)  }
  '('        { PT _ (TS _ 4)  }
  ')'        { PT _ (TS _ 5)  }
  '*'        { PT _ (TS _ 6)  }
  '+'        { PT _ (TS _ 7)  }
  ','        { PT _ (TS _ 8)  }
  '-'        { PT _ (TS _ 9)  }
  '/'        { PT _ (TS _ 10) }
  ';'        { PT _ (TS _ 11) }
  '<'        { PT _ (TS _ 12) }
  '<='       { PT _ (TS _ 13) }
  '='        { PT _ (TS _ 14) }
  '=='       { PT _ (TS _ 15) }
  '>'        { PT _ (TS _ 16) }
  '>='       { PT _ (TS _ 17) }
  '['        { PT _ (TS _ 18) }
  '[]'       { PT _ (TS _ 19) }
  ']'        { PT _ (TS _ 20) }
  'bool'     { PT _ (TS _ 21) }
  'break'    { PT _ (TS _ 22) }
  'continue' { PT _ (TS _ 23) }
  'else'     { PT _ (TS _ 24) }
  'false'    { PT _ (TS _ 25) }
  'for'      { PT _ (TS _ 26) }
  'fun'      { PT _ (TS _ 27) }
  'if'       { PT _ (TS _ 28) }
  'int'      { PT _ (TS _ 29) }
  'new'      { PT _ (TS _ 30) }
  'readonly' { PT _ (TS _ 31) }
  'return'   { PT _ (TS _ 32) }
  'string'   { PT _ (TS _ 33) }
  'to'       { PT _ (TS _ 34) }
  'true'     { PT _ (TS _ 35) }
  'void'     { PT _ (TS _ 36) }
  'while'    { PT _ (TS _ 37) }
  '{'        { PT _ (TS _ 38) }
  '||'       { PT _ (TS _ 39) }
  '}'        { PT _ (TS _ 40) }
  '~('       { PT _ (TS _ 41) }
  L_Ident    { PT _ (TV _)    }
  L_integ    { PT _ (TI _)    }
  L_quoted   { PT _ (TL _)    }

%%

Ident :: { (Gram.Abs.BNFC'Position, Gram.Abs.Ident) }
Ident  : L_Ident { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.Ident (tokenText $1)) }

Integer :: { (Gram.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (Gram.Abs.BNFC'Position, String) }
String   : L_quoted { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

PrimType :: { (Gram.Abs.BNFC'Position, Gram.Abs.PrimType) }
PrimType
  : 'bool' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.PTBool (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'string' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.PTString (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'int' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.PTInt (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }

BoolLit :: { (Gram.Abs.BNFC'Position, Gram.Abs.BoolLit) }
BoolLit
  : 'true' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.BTrue (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'false' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.BFalse (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }

TypeMod :: { (Gram.Abs.BNFC'Position, Gram.Abs.TypeMod) }
TypeMod
  : {- empty -} { (Gram.Abs.BNFC'NoPosition, Gram.Abs.TMNone Gram.Abs.BNFC'NoPosition) }
  | 'readonly' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.TMReadonly (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }

TypeName :: { (Gram.Abs.BNFC'Position, Gram.Abs.TypeName) }
TypeName
  : PrimType { (fst $1, Gram.Abs.TNPrim (fst $1) (snd $1)) }
  | ArrayType { (fst $1, Gram.Abs.TNArr (fst $1) (snd $1)) }
  | TupleType { (fst $1, Gram.Abs.TNTuple (fst $1) (snd $1)) }

TypeDef :: { (Gram.Abs.BNFC'Position, Gram.Abs.TypeDef) }
TypeDef
  : TypeName TypeMod { (fst $1, Gram.Abs.TypeDefin (fst $1) (snd $1) (snd $2)) }

ArrayType :: { (Gram.Abs.BNFC'Position, Gram.Abs.ArrayType) }
ArrayType
  : TypeName '[]' { (fst $1, Gram.Abs.TArrayType (fst $1) (snd $1)) }

TupleType :: { (Gram.Abs.BNFC'Position, Gram.Abs.TupleType) }
TupleType
  : '(' ListTupleSubType ')' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.TTupleType (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

TupleSubType :: { (Gram.Abs.BNFC'Position, Gram.Abs.TupleSubType) }
TupleSubType
  : TypeName { (fst $1, Gram.Abs.TupleSType (fst $1) (snd $1)) }

ListTupleSubType :: { (Gram.Abs.BNFC'Position, [Gram.Abs.TupleSubType]) }
ListTupleSubType
  : TupleSubType { (fst $1, (:[]) (snd $1)) }
  | TupleSubType ',' ListTupleSubType { (fst $1, (:) (snd $1) (snd $3)) }

Prog :: { (Gram.Abs.BNFC'Position, Gram.Abs.Prog) }
Prog : ListFunDef { (fst $1, Gram.Abs.Program (fst $1) (snd $1)) }

FunDef :: { (Gram.Abs.BNFC'Position, Gram.Abs.FunDef) }
FunDef
  : 'fun' FunRet Ident '(' ListFunParam ')' StmtBlock { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.FunDefin (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $5) (snd $7)) }

ListFunDef :: { (Gram.Abs.BNFC'Position, [Gram.Abs.FunDef]) }
ListFunDef
  : {- empty -} { (Gram.Abs.BNFC'NoPosition, []) }
  | FunDef ListFunDef { (fst $1, (:) (snd $1) (snd $2)) }

FunRet :: { (Gram.Abs.BNFC'Position, Gram.Abs.FunRet) }
FunRet
  : TypeName { (fst $1, Gram.Abs.FRType (fst $1) (snd $1)) }
  | 'void' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.FRVoid (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }

FunParam :: { (Gram.Abs.BNFC'Position, Gram.Abs.FunParam) }
FunParam
  : TypeDef Ident { (fst $1, Gram.Abs.FunPar (fst $1) (snd $1) (snd $2)) }

ListFunParam :: { (Gram.Abs.BNFC'Position, [Gram.Abs.FunParam]) }
ListFunParam
  : {- empty -} { (Gram.Abs.BNFC'NoPosition, []) }
  | FunParam { (fst $1, (:[]) (snd $1)) }
  | FunParam ',' ListFunParam { (fst $1, (:) (snd $1) (snd $3)) }

StmtBlock :: { (Gram.Abs.BNFC'Position, Gram.Abs.StmtBlock) }
StmtBlock
  : '{' ListBlockStmt '}' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.StmtBlck (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

BlockStmt :: { (Gram.Abs.BNFC'Position, Gram.Abs.BlockStmt) }
BlockStmt
  : Stmt { (fst $1, Gram.Abs.BSStmt (fst $1) (snd $1)) }
  | FunDef { (fst $1, Gram.Abs.BSFunDef (fst $1) (snd $1)) }

ListBlockStmt :: { (Gram.Abs.BNFC'Position, [Gram.Abs.BlockStmt]) }
ListBlockStmt
  : {- empty -} { (Gram.Abs.BNFC'NoPosition, []) }
  | BlockStmt ListBlockStmt { (fst $1, (:) (snd $1) (snd $2)) }

ArrayInit :: { (Gram.Abs.BNFC'Position, Gram.Abs.ArrayInit) }
ArrayInit
  : 'new' TypeName '[' Exp ']' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.ArrInit (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ArrayConstruction :: { (Gram.Abs.BNFC'Position, Gram.Abs.ArrayConstruction) }
ArrayConstruction
  : '[' ListConstrEl ']' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.ArrConstr (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

TupleConstruction :: { (Gram.Abs.BNFC'Position, Gram.Abs.TupleConstruction) }
TupleConstruction
  : '~(' ListConstrEl ')' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.TupleConstr (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ConstrEl :: { (Gram.Abs.BNFC'Position, Gram.Abs.ConstrEl) }
ConstrEl : Exp { (fst $1, Gram.Abs.ConstrElem (fst $1) (snd $1)) }

ListConstrEl :: { (Gram.Abs.BNFC'Position, [Gram.Abs.ConstrEl]) }
ListConstrEl
  : ConstrEl { (fst $1, (:[]) (snd $1)) }
  | ConstrEl ',' ListConstrEl { (fst $1, (:) (snd $1) (snd $3)) }

ArrayAccess :: { (Gram.Abs.BNFC'Position, Gram.Abs.ArrayAccess) }
ArrayAccess
  : Ident '[' Exp ']' { (fst $1, Gram.Abs.ArrAcc (fst $1) (snd $1) (snd $3)) }

CompOp :: { (Gram.Abs.BNFC'Position, Gram.Abs.CompOp) }
CompOp
  : '==' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.COEq (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '!=' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.CONeq (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '>' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.COGt (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '<' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.COLt (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.COGe (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.COLe (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }

AddOp :: { (Gram.Abs.BNFC'Position, Gram.Abs.AddOp) }
AddOp
  : '+' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.AOPlus (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '-' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.AOMinus (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }

MulOp :: { (Gram.Abs.BNFC'Position, Gram.Abs.MulOp) }
MulOp
  : '*' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.MOMul (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '/' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.MODiv (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | '%' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.MOMod (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }

IntLiteral :: { (Gram.Abs.BNFC'Position, Gram.Abs.IntLiteral) }
IntLiteral
  : Integer { (fst $1, Gram.Abs.LInt (fst $1) (snd $1)) }
  | '-' Integer { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.LNInt (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

Exp6 :: { (Gram.Abs.BNFC'Position, Gram.Abs.Exp) }
Exp6
  : IntLiteral { (fst $1, Gram.Abs.EInt (fst $1) (snd $1)) }
  | String { (fst $1, Gram.Abs.EString (fst $1) (snd $1)) }
  | BoolLit { (fst $1, Gram.Abs.EBool (fst $1) (snd $1)) }
  | Ident { (fst $1, Gram.Abs.EVarRef (fst $1) (snd $1)) }
  | ArrayInit { (fst $1, Gram.Abs.EArrInit (fst $1) (snd $1)) }
  | ArrayConstruction { (fst $1, Gram.Abs.EArrConstr (fst $1) (snd $1)) }
  | TupleConstruction { (fst $1, Gram.Abs.ETupleConstr (fst $1) (snd $1)) }
  | ArrayAccess { (fst $1, Gram.Abs.EArrAcc (fst $1) (snd $1)) }
  | FunCall { (fst $1, Gram.Abs.EFunCall (fst $1) (snd $1)) }
  | '(' Exp ')' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp5 :: { (Gram.Abs.BNFC'Position, Gram.Abs.Exp) }
Exp5
  : Exp5 MulOp Exp6 { (fst $1, Gram.Abs.EMul (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Exp6 { (fst $1, (snd $1)) }

Exp4 :: { (Gram.Abs.BNFC'Position, Gram.Abs.Exp) }
Exp4
  : Exp4 AddOp Exp5 { (fst $1, Gram.Abs.EAdd (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Exp5 { (fst $1, (snd $1)) }

Exp3 :: { (Gram.Abs.BNFC'Position, Gram.Abs.Exp) }
Exp3
  : Exp4 CompOp Exp4 { (fst $1, Gram.Abs.EComp (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Exp4 { (fst $1, (snd $1)) }

Exp2 :: { (Gram.Abs.BNFC'Position, Gram.Abs.Exp) }
Exp2
  : Exp2 '&&' Exp3 { (fst $1, Gram.Abs.EAnd (fst $1) (snd $1) (snd $3)) }
  | Exp3 { (fst $1, (snd $1)) }

Exp1 :: { (Gram.Abs.BNFC'Position, Gram.Abs.Exp) }
Exp1
  : Exp1 '||' Exp2 { (fst $1, Gram.Abs.EOr (fst $1) (snd $1) (snd $3)) }
  | Exp2 { (fst $1, (snd $1)) }

Exp :: { (Gram.Abs.BNFC'Position, Gram.Abs.Exp) }
Exp : Exp1 { (fst $1, (snd $1)) }

VarAssign :: { (Gram.Abs.BNFC'Position, Gram.Abs.VarAssign) }
VarAssign
  : Ident '=' Exp { (fst $1, Gram.Abs.AVar (fst $1) (snd $1) (snd $3)) }

ArrAccAssign :: { (Gram.Abs.BNFC'Position, Gram.Abs.ArrAccAssign) }
ArrAccAssign
  : ArrayAccess '=' Exp { (fst $1, Gram.Abs.AArrAcc (fst $1) (snd $1) (snd $3)) }

DeclA :: { (Gram.Abs.BNFC'Position, Gram.Abs.DeclA) }
DeclA
  : TypeDef Ident { (fst $1, Gram.Abs.DeclASingl (fst $1) (snd $1) (snd $2)) }
  | '~(' ListDeclA ')' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.DeclATuple (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListDeclA :: { (Gram.Abs.BNFC'Position, [Gram.Abs.DeclA]) }
ListDeclA
  : DeclA { (fst $1, (:[]) (snd $1)) }
  | DeclA ',' ListDeclA { (fst $1, (:) (snd $1) (snd $3)) }

FunCall :: { (Gram.Abs.BNFC'Position, Gram.Abs.FunCall) }
FunCall
  : Ident '(' ListFunArg ')' { (fst $1, Gram.Abs.FuncCall (fst $1) (snd $1) (snd $3)) }

FunArg :: { (Gram.Abs.BNFC'Position, Gram.Abs.FunArg) }
FunArg : Exp { (fst $1, Gram.Abs.FuncArg (fst $1) (snd $1)) }

ListFunArg :: { (Gram.Abs.BNFC'Position, [Gram.Abs.FunArg]) }
ListFunArg
  : {- empty -} { (Gram.Abs.BNFC'NoPosition, []) }
  | FunArg { (fst $1, (:[]) (snd $1)) }
  | FunArg ',' ListFunArg { (fst $1, (:) (snd $1) (snd $3)) }

IfBranch :: { (Gram.Abs.BNFC'Position, Gram.Abs.IfBranch) }
IfBranch
  : 'if' '(' Exp ')' Stmt { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.IfBr (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }

IfElseBranch :: { (Gram.Abs.BNFC'Position, Gram.Abs.IfElseBranch) }
IfElseBranch
  : 'if' '(' Exp ')' StmtBlock 'else' Stmt { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.IfElBr (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5) (snd $7)) }

LoopWhile :: { (Gram.Abs.BNFC'Position, Gram.Abs.LoopWhile) }
LoopWhile
  : 'while' '(' Exp ')' Stmt { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.LWhile (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5)) }

LoopFor :: { (Gram.Abs.BNFC'Position, Gram.Abs.LoopFor) }
LoopFor
  : 'for' '(' VarAssign 'to' Exp ')' Stmt { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.LFor (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $5) (snd $7)) }

Stmt :: { (Gram.Abs.BNFC'Position, Gram.Abs.Stmt) }
Stmt
  : ';' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.SEmpty (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | TypeDef Ident ';' { (fst $1, Gram.Abs.SDecl (fst $1) (snd $1) (snd $2)) }
  | VarAssign ';' { (fst $1, Gram.Abs.SAssign (fst $1) (snd $1)) }
  | ArrAccAssign ';' { (fst $1, Gram.Abs.SArrAssign (fst $1) (snd $1)) }
  | DeclA '=' Exp ';' { (fst $1, Gram.Abs.SDeclAssign (fst $1) (snd $1) (snd $3)) }
  | FunCall ';' { (fst $1, Gram.Abs.SFunCall (fst $1) (snd $1)) }
  | IfBranch { (fst $1, Gram.Abs.SIf (fst $1) (snd $1)) }
  | IfElseBranch { (fst $1, Gram.Abs.SIfEl (fst $1) (snd $1)) }
  | LoopWhile { (fst $1, Gram.Abs.SLoopWhile (fst $1) (snd $1)) }
  | LoopFor { (fst $1, Gram.Abs.SLoopFor (fst $1) (snd $1)) }
  | 'return' ';' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.SReturn (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'return' Exp ';' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.SReturnVal (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | 'continue' ';' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.SContinue (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'break' ';' { (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1), Gram.Abs.SBreak (uncurry Gram.Abs.BNFC'Position (tokenLineCol $1))) }
  | StmtBlock { (fst $1, Gram.Abs.SSubBlock (fst $1) (snd $1)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProg :: [Token] -> Err Gram.Abs.Prog
pProg = fmap snd . pProg_internal
}

